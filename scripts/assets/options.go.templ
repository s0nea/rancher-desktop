// Code generated by running `npm run postinstall` DO NOT EDIT.
//
// To rebuild this file manually, run
// node scripts/ts-wrapper.js scripts/generateCliCode.ts pkg/rancher-desktop/assets/specs/command-api.yaml \
//     src/go/rdctl/pkg/options/generated/options.go

/*
Copyright Â© 2023 SUSE LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

		http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package options

import (
	"fmt"
	"os"
	"regexp"
	"runtime"
	"strings"
	"strconv"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

/**
 * The two types `serverSettingsForJSON` and `serverSettings` both reflect the settings type in the
 * backend (as defined in `config/settings.ts`), but have different uses.
 *
 * As its name implies, the `serverSettingsForJSON` is used to generate a backend for the `rdctl set`
 * subcommand. Only fields that are explicitly changed by the user should be inserted into the JSON
 * payload, so we use pointers that are by default nil. This way we don't inadvertently change backend
 * settings to their default values.
 *
 * The problem with using pointers in a struct rather than non-pointer types is that we can't use
 * them with the golang `cmd.Flags().XVar` functions (where `X` is one of `Bool`, `String`, or `Int`).
 * We use the non-pointer fields in the `serverSettings` structure to hold them.
 *
 * See how the two structs are used in the `UpdateFieldsForJSON` function.
 */

type serverSettingsForJSON struct {
	<%- linesForJSON %>
}


type serverSettings struct {
	<%- linesWithoutJSON %>
}

var specifiedSettings serverSettings

/**
 * When an enum array is given with an option,
 * check that a specified value for that option is in its `allowedValues` list.
 */
func enumStringCheck(option string, specified string, allowedValues []string) error {
	numVals := len(allowedValues)
	singleQuotedAllowedValues := make([]string, numVals)
	for i, val := range allowedValues {
		if specified == val {
			return nil
		}
		singleQuotedAllowedValues[i] = fmt.Sprintf("'%s'", val)
	}
	var allowedString string
	if numVals == 1 {
		allowedString = singleQuotedAllowedValues[0]
	} else if numVals == 2 {
		allowedString = strings.Join(singleQuotedAllowedValues, " or ")
	} else {
		firstPart := strings.Join(singleQuotedAllowedValues[:numVals - 1], ", ")
		allowedString = fmt.Sprintf("%s, or %s", firstPart,  singleQuotedAllowedValues[numVals - 1])
	}
	return fmt.Errorf(`invalid value for option %s: <"%s">; must be %s`, option, specified, allowedString)
}

func qualifiedPlatformName() string {
	if runtime.GOOS == "darwin" {
		return "macOS"
	}
	if runtime.GOOS == "windows" {
		return "Windows"
	}
	if runtime.GOOS != "linux" {
		return runtime.GOOS
	}
	// Special case if it's running in a WSL partition, return "Linux in a WSL partition"
	contents, err := os.ReadFile("/proc/version")
	if err != nil {
		return "Linux"
	}
	ptn, err := regexp.Compile(`^Linux version \S+?-microsoft-standard-WSL2`)
	if err != nil {
		return "Linux"
	}
	match := ptn.Match(contents)
	if match && err == nil {
		return "Linux in a WSL partition"
	}
	return "Linux"
}

func UpdateCommonStartAndSetCommands(cmd *cobra.Command) {
	<%_ for (const flag of commandFlags) {
			const kebabPropertyName = kebabCase(flag.propertyName); _%>
		cmd.Flags().<%- flag.flagType %>Var(&specifiedSettings.<%- flag.capitalizedName %>, "<%- kebabPropertyName %>", <%- flag.defaultValue %>, "<%- flag.usageNote %>")
		<%_ if (flag.aliasFor || flag.notAvailable) { _%>
		cmd.Flags().MarkHidden("<%- kebabPropertyName %>")
		<%_ } _%>
	<%_ } _%>
}

func UpdateFieldsForJSON(flags *pflag.FlagSet) (*serverSettingsForJSON, error) {
	var specifiedSettingsForJSON serverSettingsForJSON
	changedSomething := false
	<%_ for (const flag of commandFlags) {
	const kebabPropertyName = kebabCase(flag.propertyName); _%>
		if flags.Changed("<%- kebabPropertyName %>") {
			<%_ if (flag.notAvailable) { _%>
				return nil, fmt.Errorf("option --<%- kebabPropertyName %> is not available on %s", qualifiedPlatformName())
			<%_ } else { _%>
				<%_ if (flag.enums) { _%>
					if err := enumStringCheck("--<%- kebabPropertyName %>", specifiedSettings.<%- flag.capitalizedName %>, <%- flag.enums %>) ; err != nil {
						return nil, err
					}
				<%_ } _%>
				specifiedSettingsForJSON.<%- flag.capitalizedName %> = &specifiedSettings.<%- flag.capitalizedName %>
				changedSomething = true
			<%_ } _%>
		}
	<% } %>
	if changedSomething {
		specifiedSettings.Version = <%- settingsVersion %>
		specifiedSettingsForJSON.Version = &specifiedSettings.Version;
		return &specifiedSettingsForJSON, nil
	}
	return nil, nil
}

func GetCommandLineArgsForStartCommand(flags *pflag.FlagSet) ([]string, error) {
	var commandLineArgs []string
	<%_ for (const flag of commandFlags) {
			const kebabPropertyName = kebabCase(flag.propertyName);
			// The app and backend use dot-separated [Cc]amelCase names, not kebab-case, so pass in the camelCase name (a few lines down)
			const actualPropertyName = flag.aliasFor || flag.propertyName;
	_%>
		if flags.Changed("<%- kebabPropertyName %>") {
			<%_ if (flag.notAvailable) { _%>
				return nil, fmt.Errorf("option --<%- kebabPropertyName %> is not available on %s", qualifiedPlatformName())
			<% } else { _%>
				<%_ if (flag.enums) { _%>
				if err := enumStringCheck("--<%- kebabPropertyName %>", specifiedSettings.<%- flag.capitalizedName %>, <%- flag.enums %>) ; err != nil {
					return commandLineArgs, err
				}
				<%_ } _%>
				commandLineArgs = append(commandLineArgs, "--<%- actualPropertyName %>"<%- flag.valuePart %>)
				<%_ } _%>
		}
	<% } %>
	return commandLineArgs, nil
}
